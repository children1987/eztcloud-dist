name: build-and-upload-to-github-delta

on:
  # 仅手动触发，不会自动运行
  workflow_dispatch:
    inputs:
      tag_name:
        description: 'Release tag (例如: v1.0.0)'
        required: true
        default: 'v1.0.0'
      release_name:
        description: 'Release 名称'
        required: false
        default: ''

permissions:
  contents: write  # 需要创建 Release 和 tag 的权限

jobs:
  build:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout isw_v2 源码
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # 获取完整 git 历史，用于创建 tag

      - name: 安装 Python 3.11
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"

      - name: 安装编译依赖 (Cython, setuptools)
        run: |
          python -m pip install --upgrade pip
          # 优先使用官方 PyPI，避免国内镜像上 Cython 版本不全导致安装失败
          pip install --no-cache-dir "cython==3.0.11" setuptools || \
          pip install --no-cache-dir cython setuptools

      - name: 获取 isw-helper 编译工具
        run: |
          set -e
          echo "克隆 isw-helper 仓库..."
          rm -rf /tmp/isw-helper
          git clone --depth 1 https://gitee.com/hotanzn/isw-helper.git /tmp/isw-helper

          if [ ! -f "/tmp/isw-helper/build_cython_delta.py" ]; then
            echo "错误: /tmp/isw-helper 中未找到 build_cython_delta.py"
            exit 1
          fi

      - name: 检查 latest_build tag 并准备增量编译
        run: |
          set -e
          CURRENT_COMMIT="${{ github.sha }}"
          LATEST_BUILD_TAG="latest_build"
          
          echo "当前 commit: $CURRENT_COMMIT"
          echo "检查 latest_build tag..."
          
          # 检查 latest_build tag 是否存在
          if git rev-parse "$LATEST_BUILD_TAG" >/dev/null 2>&1; then
            LATEST_BUILD_COMMIT=$(git rev-parse "$LATEST_BUILD_TAG")
            echo "找到 latest_build tag，指向 commit: $LATEST_BUILD_COMMIT"
            
            # 如果 latest_build tag 就是当前 commit，直接终止
            if [ "$LATEST_BUILD_COMMIT" = "$CURRENT_COMMIT" ]; then
              echo "latest_build tag 指向当前 commit，无需编译，直接终止"
              echo "SKIP_BUILD=true" >> $GITHUB_ENV
              exit 0
            fi
            
            echo "LATEST_BUILD_COMMIT=$LATEST_BUILD_COMMIT" >> $GITHUB_ENV
            echo "将进行增量编译，比较 $LATEST_BUILD_COMMIT 和 $CURRENT_COMMIT 之间的变化"
          else
            echo "未找到 latest_build tag，将进行全量编译"
            echo "SKIP_BUILD=false" >> $GITHUB_ENV
          fi

      - name: 获取已编译的目标文件（用于增量编译）
        if: env.SKIP_BUILD != 'true'
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -e
          DIST_DIR="/tmp/isw_v2-dist"
          
          echo "尝试从最新的 GitHub Release 获取已编译文件（用于增量编译）..."
          rm -rf "$DIST_DIR"
          mkdir -p "$DIST_DIR"
          
          # 获取最新的 Release（排除 draft 和 prerelease）
          RELEASE_JSON=$(gh release list --repo "${{ github.repository }}" --limit 1 --json tagName,isDraft,isPrerelease 2>/dev/null || echo "[]")
          LATEST_RELEASE=$(echo "$RELEASE_JSON" | jq -r '.[0] | select(.isDraft == false and .isPrerelease == false) | .tagName // empty' 2>/dev/null || echo "")
          
          if [ -z "$LATEST_RELEASE" ]; then
            echo "未找到已发布的 Release，将进行全量编译"
            rm -rf "$DIST_DIR"
            mkdir -p "$DIST_DIR"
          else
            echo "找到最新 Release: $LATEST_RELEASE"
            
            # 查找 tar.gz 格式的资产文件（通常是编译产物，优先查找 isw_v2-dist-linux-*.tar.gz）
            ASSET_NAME=$(gh release view "$LATEST_RELEASE" --repo "${{ github.repository }}" --json assets --jq '.assets[] | select(.name | test("isw_v2-dist.*\\.tar\\.gz$")) | .name' 2>/dev/null | head -1 || echo "")
            
            # 如果没找到 isw_v2-dist 相关的，则查找任意 tar.gz 文件
            if [ -z "$ASSET_NAME" ]; then
              ASSET_NAME=$(gh release view "$LATEST_RELEASE" --repo "${{ github.repository }}" --json assets --jq '.assets[] | select(.name | test("\\.tar\\.gz$")) | .name' 2>/dev/null | head -1 || echo "")
            fi
            
            if [ -z "$ASSET_NAME" ]; then
              echo "未找到 tar.gz 格式的编译产物，将进行全量编译"
              rm -rf "$DIST_DIR"
              mkdir -p "$DIST_DIR"
            else
              echo "找到编译产物: $ASSET_NAME"
              
              # 下载最新的编译产物到临时目录
              DOWNLOAD_DIR="/tmp/release-download"
              rm -rf "$DOWNLOAD_DIR"
              mkdir -p "$DOWNLOAD_DIR"
              
              if gh release download "$LATEST_RELEASE" \
                --pattern "$ASSET_NAME" \
                --dir "$DOWNLOAD_DIR" \
                --repo "${{ github.repository }}" 2>/dev/null; then
                
                # 查找下载的文件
                ARCHIVE_FILE=$(find "$DOWNLOAD_DIR" -name "*.tar.gz" -type f | head -1)
                
                if [ -n "$ARCHIVE_FILE" ] && [ -f "$ARCHIVE_FILE" ]; then
                  echo "解压编译产物到目标目录: $ARCHIVE_FILE"
                  tar -xzf "$ARCHIVE_FILE" -C "$DIST_DIR"
                  
                  if [ "$(ls -A "$DIST_DIR" 2>/dev/null)" ]; then
                    echo "已获取目标文件，将进行增量编译"
                  else
                    echo "解压后的目录为空，将进行全量编译"
                    rm -rf "$DIST_DIR"
                    mkdir -p "$DIST_DIR"
                  fi
                  
                  # 清理下载目录
                  rm -rf "$DOWNLOAD_DIR"
                else
                  echo "下载的文件不存在或格式不正确，将进行全量编译"
                  rm -rf "$DIST_DIR" "$DOWNLOAD_DIR"
                  mkdir -p "$DIST_DIR"
                fi
              else
                echo "下载编译产物失败，将进行全量编译"
                rm -rf "$DIST_DIR" "$DOWNLOAD_DIR"
                mkdir -p "$DIST_DIR"
              fi
            fi
          fi
          

      - name: 增量编译 isw_v2 源码为 .so
        if: env.SKIP_BUILD != 'true'
        env:
          LATEST_BUILD_COMMIT: ${{ env.LATEST_BUILD_COMMIT }}
        run: |
          set -e
          echo "GITHUB_WORKSPACE: $GITHUB_WORKSPACE"
          DIST_DIR="/tmp/isw_v2-dist"
          CURRENT_COMMIT="${{ github.sha }}"
          
          echo "当前 commit: $CURRENT_COMMIT"
          if [ -n "$LATEST_BUILD_COMMIT" ]; then
            echo "上次编译时的 commit (latest_build tag): $LATEST_BUILD_COMMIT"
          else
            echo "未找到 latest_build tag，将进行全量编译"
          fi

          cd /tmp/isw-helper

          # 如果有 latest_build commit，传递给编译脚本
          if [ -n "$LATEST_BUILD_COMMIT" ]; then
            python build_cython_delta.py \
              --source "$GITHUB_WORKSPACE" \
              --target "$DIST_DIR" \
              --platform linux \
              --exclude "test" \
              --exclude "tests" \
              --exclude "__pycache__" \
              --exclude ".git" \
              --last-commit "$LATEST_BUILD_COMMIT"
          else
            python build_cython_delta.py \
              --source "$GITHUB_WORKSPACE" \
              --target "$DIST_DIR" \
              --platform linux \
              --exclude "test" \
              --exclude "tests" \
              --exclude "__pycache__" \
              --exclude ".git"
          fi

          echo "编译完成，输出目录: $DIST_DIR"

      - name: 清理多余的 .py 源码文件
        run: |
          set -e
          DIST_DIR="/tmp/isw_v2-dist"
          echo "开始清理多余的 .py 文件，目录: $DIST_DIR"

          # 删除那些已经有对应 .so 的 .py，只保留少量必要入口文件
          find "$DIST_DIR" -name "*.py" | while read -r py; do
            base="$(basename "$py")"

            # 注意：deploy 目录下的文件已在编译阶段统一保留为源码（build_cython_delta.py::_should_keep）
            # 不会被编译，因此不会有对应的 .so，清理阶段也不会删除它们，无需在此保护

            stem="${py%.py}"
            # 同目录下存在同名的 cpython-*.so 或 .so，则认为 .py 可以删除
            if compgen -G "${stem}.cpython-"*".so" > /dev/null || [ -f "${stem}.so" ]; then
              echo "删除多余源码: $py"
              rm -f "$py"
            fi
          done

          echo "清理完成"

      - name: 删除所有 Markdown 文档（.md）
        run: |
          set -e
          DIST_DIR="/tmp/isw_v2-dist"
          echo "删除公开仓库中的所有 .md 文档，目录: $DIST_DIR"
          find "$DIST_DIR" -name "*.md" -type f -print -delete || true

      - name: 打包编译产物
        run: |
          set -e
          DIST_DIR="/tmp/isw_v2-dist"
          ARCHIVE_NAME="isw_v2-dist-linux-$(date +'%Y%m%d-%H%M%S').tar.gz"
          ARCHIVE_PATH="/tmp/$ARCHIVE_NAME"
          
          echo "打包编译产物..."
          cd "$DIST_DIR"
          tar -czf "$ARCHIVE_PATH" .
          
          echo "打包完成: $ARCHIVE_PATH"
          ls -lh "$ARCHIVE_PATH"
          
          # 保存归档路径供后续步骤使用
          echo "ARCHIVE_PATH=$ARCHIVE_PATH" >> $GITHUB_ENV
          echo "ARCHIVE_NAME=$ARCHIVE_NAME" >> $GITHUB_ENV

      - name: 更新 latest_build tag
        if: env.SKIP_BUILD != 'true'
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -e
          LATEST_BUILD_TAG="latest_build"
          CURRENT_COMMIT="${{ github.sha }}"
          GITHUB_REPO="${{ github.repository }}"
          
          echo "更新 latest_build tag 到当前 commit: $CURRENT_COMMIT"
          
          # 配置 git
          git config user.name "GitHub Actions"
          git config user.email "actions@github.com"
          
          # 使用 x-access-token 前缀来避免 token 被误识别为密码
          # 设置远程 URL 使用 token 认证
          git remote set-url origin "https://x-access-token:${GITHUB_TOKEN}@github.com/${GITHUB_REPO}.git"
          
          # 获取最新的远程信息
          git fetch origin --tags --force
          
          # 删除旧的 latest_build tag（如果存在）
          if git rev-parse "$LATEST_BUILD_TAG" >/dev/null 2>&1; then
            echo "删除本地 latest_build tag"
            git tag -d "$LATEST_BUILD_TAG" 2>/dev/null || true
          fi
          
          # 删除远程 latest_build tag（如果存在）
          if git ls-remote --tags origin "$LATEST_BUILD_TAG" | grep -q "$LATEST_BUILD_TAG"; then
            echo "删除远程 latest_build tag"
            git push origin ":refs/tags/$LATEST_BUILD_TAG" 2>/dev/null || true
          fi
          
          # 创建新的 latest_build tag（指向当前提交）
          git tag -a "$LATEST_BUILD_TAG" -m "Latest build commit: $CURRENT_COMMIT - $(date +'%Y-%m-%d %H:%M:%S')" "$CURRENT_COMMIT"
          git push origin "$LATEST_BUILD_TAG"
          
          echo "latest_build tag 已更新: $CURRENT_COMMIT"

      - name: 创建 GitHub Release 并上传编译产物
        if: env.SKIP_BUILD != 'true'
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -e
          
          TAG_NAME="${{ github.event.inputs.tag_name }}"
          RELEASE_NAME="${{ github.event.inputs.release_name }}"
          GITHUB_REPO="${{ github.repository }}"
          CURRENT_COMMIT="${{ github.sha }}"
          
          if [ -z "$RELEASE_NAME" ]; then
            RELEASE_NAME="isw_v2 编译产物 (增量编译) - $(date +'%Y-%m-%d %H:%M:%S')"
          fi
          
          echo "创建 Release: $TAG_NAME"
          echo "Release 名称: $RELEASE_NAME"
          echo "归档文件: $ARCHIVE_PATH"
          
          # 配置 git
          git config user.name "GitHub Actions"
          git config user.email "actions@github.com"
          
          # 使用 x-access-token 前缀来避免 token 被误识别为密码
          # 设置远程 URL 使用 token 认证
          git remote set-url origin "https://x-access-token:${GITHUB_TOKEN}@github.com/${GITHUB_REPO}.git"
          
          # 获取最新的远程信息
          git fetch origin --tags --force
          
          # 检查 tag 是否已存在（本地和远程）
          if git rev-parse "$TAG_NAME" >/dev/null 2>&1; then
            echo "警告: Tag $TAG_NAME 已存在，将删除旧 tag"
            git tag -d "$TAG_NAME" 2>/dev/null || true
          fi
          
          # 检查远程 tag 是否存在
          if git ls-remote --tags origin "$TAG_NAME" | grep -q "$TAG_NAME"; then
            echo "警告: 远程 Tag $TAG_NAME 已存在，将删除"
            git push origin ":refs/tags/$TAG_NAME" 2>/dev/null || true
          fi
          
          # 创建 tag（指向当前提交）
          git tag -a "$TAG_NAME" -m "$RELEASE_NAME" "$CURRENT_COMMIT"
          git push origin "$TAG_NAME"
          
          # 等待 GitHub API 识别新 tag（短暂延迟）
          echo "等待 GitHub API 识别新 tag..."
          sleep 5
          
          # 检查 Release 是否已存在，如果存在则删除
          if gh release view "$TAG_NAME" --repo "${{ github.repository }}" >/dev/null 2>&1; then
            echo "警告: Release $TAG_NAME 已存在，将删除旧 Release"
            gh release delete "$TAG_NAME" --yes --repo "${{ github.repository }}" || true
            sleep 2
          fi
          
          # 创建 Release 并上传文件
          NOTES="自动构建的 isw_v2 编译产物（增量编译）

            构建时间: $(date +'%Y-%m-%d %H:%M:%S')
            构建分支: ${{ github.ref }}
            构建提交: ${{ github.sha }}
            
            **使用说明:**
            1. 下载并解压归档文件
            2. 替换部署目录中的对应文件
            3. 重启服务"
          
          gh release create "$TAG_NAME" \
            --title "$RELEASE_NAME" \
            --notes "$NOTES" \
            "$ARCHIVE_PATH" \
            --repo "${{ github.repository }}"
          
          echo "Release 创建完成: https://github.com/${{ github.repository }}/releases/tag/$TAG_NAME"

      - name: 输出下载链接
        if: env.SKIP_BUILD != 'true'
        run: |
          TAG_NAME="${{ github.event.inputs.tag_name }}"
          echo "=========================================="
          echo "编译产物已上传到 GitHub Release"
          echo "=========================================="
          echo "Release 链接: https://github.com/${{ github.repository }}/releases/tag/$TAG_NAME"
          echo "归档文件: $ARCHIVE_NAME"
          echo "latest_build tag 已更新到: ${{ github.sha }}"
          echo "=========================================="

